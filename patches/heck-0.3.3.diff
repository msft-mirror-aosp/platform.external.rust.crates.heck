diff --git a/0.3.3/Android.bp b/0.3.3/Android.bp
new file mode 100644
index 0000000..65601b5
--- /dev/null
+++ b/0.3.3/Android.bp
@@ -0,0 +1,69 @@
+// This file is generated by cargo2android.py --config cargo2android.json.
+// Do not modify this file as changes will be overridden on upgrade.
+
+package {
+    default_applicable_licenses: ["external_rust_crates_heck_license_0_3_3"],
+}
+
+// Added automatically by a large-scale-change that took the approach of
+// 'apply every license found to every target'. While this makes sure we respect
+// every license restriction, it may not be entirely correct.
+//
+// e.g. GPL in an MIT project might only apply to the contrib/ directory.
+//
+// Please consider splitting the single license below into multiple licenses,
+// taking care not to lose any license_kind information, and overriding the
+// default license using the 'licenses: [...]' property on targets as needed.
+//
+// For unused files, consider creating a 'fileGroup' with "//visibility:private"
+// to attach the license to, and including a comment whether the files may be
+// used in the current project.
+//
+// large-scale-change included anything that looked like it might be a license
+// text as a license_text. e.g. LICENSE, NOTICE, COPYING etc.
+//
+// Please consider removing redundant or irrelevant files from 'license_text:'.
+// See: http://go/android-license-faq
+license {
+    name: "external_rust_crates_heck_license_0_3_3",
+    visibility: [":__subpackages__"],
+    license_kinds: [
+        "SPDX-license-identifier-Apache-2.0",
+        "SPDX-license-identifier-MIT",
+    ],
+    license_text: [
+        "LICENSE-APACHE",
+        "LICENSE-MIT",
+    ],
+}
+
+rust_test {
+    name: "heck_test_src_lib_deprecated",
+    host_supported: true,
+    crate_name: "heck",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.3.3",
+    srcs: ["src/lib.rs"],
+    test_suites: ["general-tests"],
+    auto_gen_config: true,
+    test_options: {
+        unit_test: true,
+    },
+    edition: "2018",
+    rustlibs: [
+        "libunicode_segmentation",
+    ],
+}
+
+rust_library {
+    name: "libheck_deprecated",
+    host_supported: true,
+    crate_name: "heck",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.3.3",
+    srcs: ["src/lib.rs"],
+    edition: "2018",
+    rustlibs: [
+        "libunicode_segmentation",
+    ],
+}
diff --git a/0.3.3/Cargo.toml b/0.3.3/Cargo.toml
new file mode 100644
index 0000000..fc9c28d
--- /dev/null
+++ b/0.3.3/Cargo.toml
@@ -0,0 +1,27 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g., crates.io) dependencies
+#
+# If you believe there's an error in this file please file an
+# issue against the rust-lang/cargo repository. If you're
+# editing this file be aware that the upstream Cargo.toml
+# will likely look very different (and much more reasonable)
+
+[package]
+edition = "2018"
+name = "heck"
+version = "0.3.3"
+authors = ["Without Boats <woboats@gmail.com>"]
+include = ["src/**/*", "LICENSE-*", "README.md", "CHANGELOG.md"]
+description = "heck is a case conversion library."
+homepage = "https://github.com/withoutboats/heck"
+documentation = "https://docs.rs/heck"
+readme = "README.md"
+keywords = ["string", "case", "camel", "snake", "unicode"]
+license = "MIT OR Apache-2.0"
+repository = "https://github.com/withoutboats/heck"
+[dependencies.unicode-segmentation]
+version = "1.2.0"
diff --git a/0.3.3/Cargo.toml.orig b/0.3.3/Cargo.toml.orig
new file mode 100644
index 0000000..80acd39
--- /dev/null
+++ b/0.3.3/Cargo.toml.orig
@@ -0,0 +1,16 @@
+[package]
+authors = ["Without Boats <woboats@gmail.com>"]
+name = "heck"
+version = "0.3.3"
+edition = "2018"
+license = "MIT OR Apache-2.0"
+description = "heck is a case conversion library."
+homepage = "https://github.com/withoutboats/heck"
+repository = "https://github.com/withoutboats/heck"
+documentation = "https://docs.rs/heck"
+keywords = ["string", "case", "camel", "snake", "unicode"]
+readme = "README.md"
+include = ["src/**/*", "LICENSE-*", "README.md", "CHANGELOG.md"]
+
+[dependencies]
+unicode-segmentation = "1.2.0"
diff --git a/0.3.3/LICENSE b/0.3.3/LICENSE
new file mode 120000
index 0000000..6b579aa
--- /dev/null
+++ b/0.3.3/LICENSE
@@ -0,0 +1 @@
+LICENSE-APACHE
\ No newline at end of file
diff --git a/0.3.3/LICENSE-APACHE b/0.3.3/LICENSE-APACHE
new file mode 100644
index 0000000..16fe87b
--- /dev/null
+++ b/0.3.3/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/0.3.3/LICENSE-MIT b/0.3.3/LICENSE-MIT
new file mode 100644
index 0000000..e69282e
--- /dev/null
+++ b/0.3.3/LICENSE-MIT
@@ -0,0 +1,25 @@
+Copyright (c) 2015 The Rust Project Developers
+
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/0.3.3/METADATA b/0.3.3/METADATA
new file mode 100644
index 0000000..dd9970c
--- /dev/null
+++ b/0.3.3/METADATA
@@ -0,0 +1,19 @@
+name: "heck"
+description: "heck is a case conversion library."
+third_party {
+  url {
+    type: HOMEPAGE
+    value: "https://crates.io/crates/heck"
+  }
+  url {
+    type: ARCHIVE
+    value: "https://static.crates.io/crates/heck/heck-0.3.3.crate"
+  }
+  version: "0.3.3"
+  license_type: NOTICE
+  last_upgrade_date {
+    year: 2021
+    month: 6
+    day: 21
+  }
+}
diff --git a/0.3.3/MODULE_LICENSE_APACHE2 b/0.3.3/MODULE_LICENSE_APACHE2
new file mode 100644
index 0000000..e69de29
diff --git a/0.3.3/NOTICE b/0.3.3/NOTICE
new file mode 120000
index 0000000..7a694c9
--- /dev/null
+++ b/0.3.3/NOTICE
@@ -0,0 +1 @@
+LICENSE
\ No newline at end of file
diff --git a/0.3.3/OWNERS b/0.3.3/OWNERS
new file mode 100644
index 0000000..46fc303
--- /dev/null
+++ b/0.3.3/OWNERS
@@ -0,0 +1 @@
+include platform/prebuilts/rust:/OWNERS
diff --git a/0.3.3/README.md b/0.3.3/README.md
new file mode 100644
index 0000000..33f2a5d
--- /dev/null
+++ b/0.3.3/README.md
@@ -0,0 +1,63 @@
+# **heck** is a case conversion library
+
+!["I specifically requested the opposite of this."](./no_step_on_snek.png)
+
+This library exists to provide case conversion between common cases like
+CamelCase and snake_case. It is intended to be unicode aware, internally
+consistent, and reasonably well performing.
+
+## Definition of a word boundary
+
+Word boundaries are defined as the "unicode words" defined in the
+`unicode_segmentation` library, as well as within those words in this manner:
+
+1. All underscore characters are considered word boundaries.
+2. If an uppercase character is followed by lowercase letters, a word boundary
+is considered to be just prior to that uppercase character.
+3. If multiple uppercase characters are consecutive, they are considered to be
+within a single word, except that the last will be part of the next word if it
+is followed by lowercase characters (see rule 2).
+
+That is, "HelloWorld" is segmented `Hello|World` whereas "XMLHttpRequest" is
+segmented `XML|Http|Request`.
+
+Characters not within words (such as spaces, punctuations, and underscores)
+are not included in the output string except as they are a part of the case
+being converted to. Multiple adjacent word boundaries (such as a series of
+underscores) are folded into one. ("hello__world" in snake case is therefore
+"hello_world", not the exact same string). Leading or trailing word boundary
+indicators are dropped, except insofar as CamelCase capitalizes the first word.
+
+## Cases contained in this library:
+
+1. CamelCase
+2. snake_case
+3. kebab-case
+4. SHOUTY_SNAKE_CASE
+5. mixedCase
+6. Title Case
+7. SHOUTY-KEBAB-CASE
+
+## Contributing
+
+PRs of additional well-established cases welcome.
+
+This library is a little bit opinionated (dropping punctuation, for example).
+If that doesn't fit your use case, I hope there is another crate that does. I
+would prefer **not** to receive PRs to make this behavior more configurable.
+
+Bug reports & fixes always welcome. :-)
+
+## MSRV
+
+The minimum supported Rust version for this crate is 1.32.0. This may change in
+minor or patch releases, but we probably won't ever require a very recent
+version. If you would like to have a stronger guarantee than that, please open
+an issue.
+
+## License
+
+heck is distributed under the terms of both the MIT license and the
+Apache License (Version 2.0).
+
+See LICENSE-APACHE and LICENSE-MIT for details.
diff --git a/0.3.3/TEST_MAPPING b/0.3.3/TEST_MAPPING
new file mode 100644
index 0000000..e5f5c4c
--- /dev/null
+++ b/0.3.3/TEST_MAPPING
@@ -0,0 +1,27 @@
+// Generated by update_crate_tests.py for tests that depend on this crate.
+{
+  "imports": [
+    {
+      "path": "external/rust/crates/argh"
+    },
+    {
+      "path": "external/rust/crates/base64"
+    }
+  ],
+  "presubmit": [
+    {
+      "name": "authfs_device_test_src_lib"
+    },
+    {
+      "name": "heck_test_src_lib"
+    }
+  ],
+  "presubmit-rust": [
+    {
+      "name": "authfs_device_test_src_lib"
+    },
+    {
+      "name": "heck_test_src_lib"
+    }
+  ]
+}
diff --git a/0.3.3/cargo2android.json b/0.3.3/cargo2android.json
new file mode 100644
index 0000000..d36fb44
--- /dev/null
+++ b/0.3.3/cargo2android.json
@@ -0,0 +1,5 @@
+{
+  "device": true,
+  "run": true,
+  "tests": true
+}
\ No newline at end of file
diff --git a/0.3.3/src/camel.rs b/0.3.3/src/camel.rs
new file mode 100644
index 0000000..6949435
--- /dev/null
+++ b/0.3.3/src/camel.rs
@@ -0,0 +1,50 @@
+use crate::{capitalize, transform};
+
+/// This trait defines a camel case conversion.
+///
+/// In CamelCase, word boundaries are indicated by capital letters, including
+/// the first word.
+///
+/// ## Example:
+///
+/// ```rust
+/// use heck::CamelCase;
+///
+/// let sentence = "We are not in the least afraid of ruins.";
+/// assert_eq!(sentence.to_camel_case(), "WeAreNotInTheLeastAfraidOfRuins");
+/// ```
+pub trait CamelCase: ToOwned {
+    /// Convert this type to camel case.
+    fn to_camel_case(&self) -> Self::Owned;
+}
+
+impl CamelCase for str {
+    fn to_camel_case(&self) -> String {
+        transform(self, capitalize, |_| {})
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::CamelCase;
+
+    macro_rules! t {
+        ($t:ident : $s1:expr => $s2:expr) => {
+            #[test]
+            fn $t() {
+                assert_eq!($s1.to_camel_case(), $s2)
+            }
+        };
+    }
+
+    t!(test1: "CamelCase" => "CamelCase");
+    t!(test2: "This is Human case." => "ThisIsHumanCase");
+    t!(test3: "MixedUP_CamelCase, with some Spaces" => "MixedUpCamelCaseWithSomeSpaces");
+    t!(test4: "mixed_up_ snake_case, with some _spaces" => "MixedUpSnakeCaseWithSomeSpaces");
+    t!(test5: "kebab-case" => "KebabCase");
+    t!(test6: "SHOUTY_SNAKE_CASE" => "ShoutySnakeCase");
+    t!(test7: "snake_case" => "SnakeCase");
+    t!(test8: "this-contains_ ALLKinds OfWord_Boundaries" => "ThisContainsAllKindsOfWordBoundaries");
+    t!(test9: "XΣXΣ baﬄe" => "XσxςBaﬄe");
+    t!(test10: "XMLHttpRequest" => "XmlHttpRequest");
+}
diff --git a/0.3.3/src/kebab.rs b/0.3.3/src/kebab.rs
new file mode 100644
index 0000000..75e5978
--- /dev/null
+++ b/0.3.3/src/kebab.rs
@@ -0,0 +1,49 @@
+use crate::{lowercase, transform};
+
+/// This trait defines a kebab case conversion.
+///
+/// In kebab-case, word boundaries are indicated by hyphens.
+///
+/// ## Example:
+///
+/// ```rust
+/// use heck::KebabCase;
+///
+/// let sentence = "We are going to inherit the earth.";
+/// assert_eq!(sentence.to_kebab_case(), "we-are-going-to-inherit-the-earth");
+/// ```
+pub trait KebabCase: ToOwned {
+    /// Convert this type to kebab case.
+    fn to_kebab_case(&self) -> Self::Owned;
+}
+
+impl KebabCase for str {
+    fn to_kebab_case(&self) -> Self::Owned {
+        transform(self, lowercase, |s| s.push('-'))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::KebabCase;
+
+    macro_rules! t {
+        ($t:ident : $s1:expr => $s2:expr) => {
+            #[test]
+            fn $t() {
+                assert_eq!($s1.to_kebab_case(), $s2)
+            }
+        };
+    }
+
+    t!(test1: "CamelCase" => "camel-case");
+    t!(test2: "This is Human case." => "this-is-human-case");
+    t!(test3: "MixedUP CamelCase, with some Spaces" => "mixed-up-camel-case-with-some-spaces");
+    t!(test4: "mixed_up_ snake_case with some _spaces" => "mixed-up-snake-case-with-some-spaces");
+    t!(test5: "kebab-case" => "kebab-case");
+    t!(test6: "SHOUTY_SNAKE_CASE" => "shouty-snake-case");
+    t!(test7: "snake_case" => "snake-case");
+    t!(test8: "this-contains_ ALLKinds OfWord_Boundaries" => "this-contains-all-kinds-of-word-boundaries");
+    t!(test9: "XΣXΣ baﬄe" => "xσxς-baﬄe");
+    t!(test10: "XMLHttpRequest" => "xml-http-request");
+}
diff --git a/0.3.3/src/lib.rs b/0.3.3/src/lib.rs
new file mode 100644
index 0000000..00a9fbe
--- /dev/null
+++ b/0.3.3/src/lib.rs
@@ -0,0 +1,181 @@
+//! **heck** is a case conversion library.
+//!
+//! This library exists to provide case conversion between common cases like
+//! CamelCase and snake_case. It is intended to be unicode aware, internally,
+//! consistent, and reasonably well performing.
+//!
+//! ## Definition of a word boundary
+//!
+//! Word boundaries are defined as the "unicode words" defined in the
+//! `unicode_segmentation` library, as well as within those words in this
+//! manner:
+//!
+//! 1. All underscore characters are considered word boundaries.
+//! 2. If an uppercase character is followed by lowercase letters, a word
+//! boundary is considered to be just prior to that uppercase character.
+//! 3. If multiple uppercase characters are consecutive, they are considered to
+//! be within a single word, except that the last will be part of the next word
+//! if it is followed by lowercase characters (see rule 2).
+//!
+//! That is, "HelloWorld" is segmented `Hello|World` whereas "XMLHttpRequest" is
+//! segmented `XML|Http|Request`.
+//!
+//! Characters not within words (such as spaces, punctuations, and underscores)
+//! are not included in the output string except as they are a part of the case
+//! being converted to. Multiple adjacent word boundaries (such as a series of
+//! underscores) are folded into one. ("hello__world" in snake case is therefore
+//! "hello_world", not the exact same string). Leading or trailing word boundary
+//! indicators are dropped, except insofar as CamelCase capitalizes the first
+//! word.
+//!
+//! ### Cases contained in this library:
+//!
+//! 1. CamelCase
+//! 2. snake_case
+//! 3. kebab-case
+//! 4. SHOUTY_SNAKE_CASE
+//! 5. mixedCase
+//! 6. Title Case
+//! 7. SHOUTY-KEBAB-CASE
+#![deny(missing_docs)]
+
+mod camel;
+mod kebab;
+mod mixed;
+mod shouty_kebab;
+mod shouty_snake;
+mod snake;
+mod title;
+
+pub use camel::CamelCase;
+pub use kebab::KebabCase;
+pub use mixed::MixedCase;
+pub use shouty_kebab::ShoutyKebabCase;
+pub use shouty_snake::{ShoutySnakeCase, ShoutySnekCase};
+pub use snake::{SnakeCase, SnekCase};
+pub use title::TitleCase;
+
+use unicode_segmentation::UnicodeSegmentation;
+
+fn transform<F, G>(s: &str, with_word: F, boundary: G) -> String
+where
+    F: Fn(&str, &mut String),
+    G: Fn(&mut String),
+{
+    /// Tracks the current 'mode' of the transformation algorithm as it scans
+    /// the input string.
+    ///
+    /// The mode is a tri-state which tracks the case of the last cased
+    /// character of the current word. If there is no cased character
+    /// (either lowercase or uppercase) since the previous word boundary,
+    /// than the mode is `Boundary`. If the last cased character is lowercase,
+    /// then the mode is `Lowercase`. Othertherwise, the mode is
+    /// `Uppercase`.
+    #[derive(Clone, Copy, PartialEq)]
+    enum WordMode {
+        /// There have been no lowercase or uppercase characters in the current
+        /// word.
+        Boundary,
+        /// The previous cased character in the current word is lowercase.
+        Lowercase,
+        /// The previous cased character in the current word is uppercase.
+        Uppercase,
+    }
+
+    let mut out = String::new();
+    let mut first_word = true;
+
+    for word in s.unicode_words() {
+        let mut char_indices = word.char_indices().peekable();
+        let mut init = 0;
+        let mut mode = WordMode::Boundary;
+
+        while let Some((i, c)) = char_indices.next() {
+            // Skip underscore characters
+            if c == '_' {
+                if init == i {
+                    init += 1;
+                }
+                continue;
+            }
+
+            if let Some(&(next_i, next)) = char_indices.peek() {
+                // The mode including the current character, assuming the
+                // current character does not result in a word boundary.
+                let next_mode = if c.is_lowercase() {
+                    WordMode::Lowercase
+                } else if c.is_uppercase() {
+                    WordMode::Uppercase
+                } else {
+                    mode
+                };
+
+                // Word boundary after if next is underscore or current is
+                // not uppercase and next is uppercase
+                if next == '_' || (next_mode == WordMode::Lowercase && next.is_uppercase()) {
+                    if !first_word {
+                        boundary(&mut out);
+                    }
+                    with_word(&word[init..next_i], &mut out);
+                    first_word = false;
+                    init = next_i;
+                    mode = WordMode::Boundary;
+
+                // Otherwise if current and previous are uppercase and next
+                // is lowercase, word boundary before
+                } else if mode == WordMode::Uppercase && c.is_uppercase() && next.is_lowercase() {
+                    if !first_word {
+                        boundary(&mut out);
+                    } else {
+                        first_word = false;
+                    }
+                    with_word(&word[init..i], &mut out);
+                    init = i;
+                    mode = WordMode::Boundary;
+
+                // Otherwise no word boundary, just update the mode
+                } else {
+                    mode = next_mode;
+                }
+            } else {
+                // Collect trailing characters as a word
+                if !first_word {
+                    boundary(&mut out);
+                } else {
+                    first_word = false;
+                }
+                with_word(&word[init..], &mut out);
+                break;
+            }
+        }
+    }
+
+    out
+}
+
+fn lowercase(s: &str, out: &mut String) {
+    let mut chars = s.chars().peekable();
+    while let Some(c) = chars.next() {
+        if c == 'Σ' && chars.peek().is_none() {
+            out.push('ς');
+        } else {
+            out.extend(c.to_lowercase());
+        }
+    }
+}
+
+fn uppercase(s: &str, out: &mut String) {
+    for c in s.chars() {
+        out.extend(c.to_uppercase())
+    }
+}
+
+fn capitalize(s: &str, out: &mut String) {
+    let mut char_indices = s.char_indices();
+    if let Some((_, c)) = char_indices.next() {
+        out.extend(c.to_uppercase());
+        if let Some((i, _)) = char_indices.next() {
+            lowercase(&s[i..], out);
+        }
+    }
+}
diff --git a/0.3.3/src/mixed.rs b/0.3.3/src/mixed.rs
new file mode 100644
index 0000000..71089f2
--- /dev/null
+++ b/0.3.3/src/mixed.rs
@@ -0,0 +1,61 @@
+use crate::{capitalize, lowercase, transform};
+
+/// This trait defines a mixed case conversion.
+///
+/// In mixedCase, word boundaries are indicated by capital letters, excepting
+/// the first word.
+///
+/// ## Example:
+///
+/// ```rust
+/// use heck::MixedCase;
+///
+/// let sentence = "It is we who built these palaces and cities.";
+/// assert_eq!(sentence.to_mixed_case(), "itIsWeWhoBuiltThesePalacesAndCities");
+/// ```
+pub trait MixedCase: ToOwned {
+    /// Convert this type to mixed case.
+    fn to_mixed_case(&self) -> Self::Owned;
+}
+
+impl MixedCase for str {
+    fn to_mixed_case(&self) -> String {
+        transform(
+            self,
+            |s, out| {
+                if out.is_empty() {
+                    lowercase(s, out);
+                } else {
+                    capitalize(s, out)
+                }
+            },
+            |_| {},
+        )
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::MixedCase;
+
+    macro_rules! t {
+        ($t:ident : $s1:expr => $s2:expr) => {
+            #[test]
+            fn $t() {
+                assert_eq!($s1.to_mixed_case(), $s2)
+            }
+        };
+    }
+
+    t!(test1: "CamelCase" => "camelCase");
+    t!(test2: "This is Human case." => "thisIsHumanCase");
+    t!(test3: "MixedUP CamelCase, with some Spaces" => "mixedUpCamelCaseWithSomeSpaces");
+    t!(test4: "mixed_up_ snake_case, with some _spaces" => "mixedUpSnakeCaseWithSomeSpaces");
+    t!(test5: "kebab-case" => "kebabCase");
+    t!(test6: "SHOUTY_SNAKE_CASE" => "shoutySnakeCase");
+    t!(test7: "snake_case" => "snakeCase");
+    t!(test8: "this-contains_ ALLKinds OfWord_Boundaries" => "thisContainsAllKindsOfWordBoundaries");
+    t!(test9: "XΣXΣ baﬄe" => "xσxςBaﬄe");
+    t!(test10: "XMLHttpRequest" => "xmlHttpRequest");
+    // TODO unicode tests
+}
diff --git a/0.3.3/src/shouty_kebab.rs b/0.3.3/src/shouty_kebab.rs
new file mode 100644
index 0000000..0225471
--- /dev/null
+++ b/0.3.3/src/shouty_kebab.rs
@@ -0,0 +1,51 @@
+use crate::{transform, uppercase};
+
+/// This trait defines a shouty kebab case conversion.
+///
+/// In SHOUTY-KEBAB-CASE, word boundaries are indicated by hyphens and all
+/// words are in uppercase.
+///
+/// ## Example:
+///
+/// ```rust
+/// use heck::ShoutyKebabCase;
+///
+/// let sentence = "We are going to inherit the earth.";
+/// assert_eq!(sentence.to_shouty_kebab_case(), "WE-ARE-GOING-TO-INHERIT-THE-EARTH");
+/// ```
+pub trait ShoutyKebabCase: ToOwned {
+    /// Convert this type to shouty kebab case.
+    fn to_shouty_kebab_case(&self) -> Self::Owned;
+}
+
+impl ShoutyKebabCase for str {
+    fn to_shouty_kebab_case(&self) -> Self::Owned {
+        transform(self, uppercase, |s| s.push('-'))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::ShoutyKebabCase;
+
+    macro_rules! t {
+        ($t:ident : $s1:expr => $s2:expr) => {
+            #[test]
+            fn $t() {
+                assert_eq!($s1.to_shouty_kebab_case(), $s2)
+            }
+        };
+    }
+
+    t!(test1: "CamelCase" => "CAMEL-CASE");
+    t!(test2: "This is Human case." => "THIS-IS-HUMAN-CASE");
+    t!(test3: "MixedUP CamelCase, with some Spaces" => "MIXED-UP-CAMEL-CASE-WITH-SOME-SPACES");
+    t!(test4: "mixed_up_ snake_case with some _spaces" => "MIXED-UP-SNAKE-CASE-WITH-SOME-SPACES");
+    t!(test5: "kebab-case" => "KEBAB-CASE");
+    t!(test6: "SHOUTY_SNAKE_CASE" => "SHOUTY-SNAKE-CASE");
+    t!(test7: "snake_case" => "SNAKE-CASE");
+    t!(test8: "this-contains_ ALLKinds OfWord_Boundaries" => "THIS-CONTAINS-ALL-KINDS-OF-WORD-BOUNDARIES");
+    t!(test9: "XΣXΣ baﬄe" => "XΣXΣ-BAFFLE");
+    t!(test10: "XMLHttpRequest" => "XML-HTTP-REQUEST");
+    t!(test11: "SHOUTY-KEBAB-CASE" => "SHOUTY-KEBAB-CASE");
+}
diff --git a/0.3.3/src/shouty_snake.rs b/0.3.3/src/shouty_snake.rs
new file mode 100644
index 0000000..8f4289a
--- /dev/null
+++ b/0.3.3/src/shouty_snake.rs
@@ -0,0 +1,64 @@
+use crate::{transform, uppercase};
+
+/// This trait defines a shouty snake case conversion.
+///
+/// In SHOUTY_SNAKE_CASE, word boundaries are indicated by underscores and all
+/// words are in uppercase.
+///
+/// ## Example:
+///
+/// ```rust
+/// use heck::ShoutySnakeCase;
+///     
+/// let sentence = "That world is growing in this minute.";
+/// assert_eq!(sentence.to_shouty_snake_case(), "THAT_WORLD_IS_GROWING_IN_THIS_MINUTE");
+/// ```
+pub trait ShoutySnakeCase: ToOwned {
+    /// Convert this type to shouty snake case.
+    fn to_shouty_snake_case(&self) -> Self::Owned;
+}
+
+/// Oh heck, ShoutySnekCase is an alias for ShoutySnakeCase. See ShoutySnakeCase
+/// for more documentation.
+pub trait ShoutySnekCase: ToOwned {
+    /// CONVERT THIS TYPE TO SNEK CASE.
+    #[allow(non_snake_case)]
+    fn TO_SHOUTY_SNEK_CASE(&self) -> Self::Owned;
+}
+
+impl<T: ?Sized + ShoutySnakeCase> ShoutySnekCase for T {
+    fn TO_SHOUTY_SNEK_CASE(&self) -> Self::Owned {
+        self.to_shouty_snake_case()
+    }
+}
+
+impl ShoutySnakeCase for str {
+    fn to_shouty_snake_case(&self) -> Self::Owned {
+        transform(self, uppercase, |s| s.push('_'))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::ShoutySnakeCase;
+
+    macro_rules! t {
+        ($t:ident : $s1:expr => $s2:expr) => {
+            #[test]
+            fn $t() {
+                assert_eq!($s1.to_shouty_snake_case(), $s2)
+            }
+        };
+    }
+
+    t!(test1: "CamelCase" => "CAMEL_CASE");
+    t!(test2: "This is Human case." => "THIS_IS_HUMAN_CASE");
+    t!(test3: "MixedUP CamelCase, with some Spaces" => "MIXED_UP_CAMEL_CASE_WITH_SOME_SPACES");
+    t!(test4: "mixed_up_snake_case with some _spaces" => "MIXED_UP_SNAKE_CASE_WITH_SOME_SPACES");
+    t!(test5: "kebab-case" => "KEBAB_CASE");
+    t!(test6: "SHOUTY_SNAKE_CASE" => "SHOUTY_SNAKE_CASE");
+    t!(test7: "snake_case" => "SNAKE_CASE");
+    t!(test8: "this-contains_ ALLKinds OfWord_Boundaries" => "THIS_CONTAINS_ALL_KINDS_OF_WORD_BOUNDARIES");
+    t!(test9: "XΣXΣ baﬄe" => "XΣXΣ_BAFFLE");
+    t!(test10: "XMLHttpRequest" => "XML_HTTP_REQUEST");
+}
diff --git a/0.3.3/src/snake.rs b/0.3.3/src/snake.rs
new file mode 100644
index 0000000..c1ad376
--- /dev/null
+++ b/0.3.3/src/snake.rs
@@ -0,0 +1,77 @@
+use crate::{lowercase, transform};
+
+/// This trait defines a snake case conversion.
+///
+/// In snake_case, word boundaries are indicated by underscores.
+///
+/// ## Example:
+///
+/// ```rust
+/// use heck::SnakeCase;
+///
+/// let sentence = "We carry a new world here, in our hearts.";
+/// assert_eq!(sentence.to_snake_case(), "we_carry_a_new_world_here_in_our_hearts");
+/// ```
+pub trait SnakeCase: ToOwned {
+    /// Convert this type to snake case.
+    fn to_snake_case(&self) -> Self::Owned;
+}
+
+/// Oh heck, SnekCase is an alias for SnakeCase. See SnakeCase for
+/// more documentation.
+pub trait SnekCase: ToOwned {
+    /// Convert this type to snek case.
+    fn to_snek_case(&self) -> Self::Owned;
+}
+
+impl<T: ?Sized + SnakeCase> SnekCase for T {
+    fn to_snek_case(&self) -> Self::Owned {
+        self.to_snake_case()
+    }
+}
+
+impl SnakeCase for str {
+    fn to_snake_case(&self) -> String {
+        transform(self, lowercase, |s| s.push('_'))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::SnakeCase;
+
+    macro_rules! t {
+        ($t:ident : $s1:expr => $s2:expr) => {
+            #[test]
+            fn $t() {
+                assert_eq!($s1.to_snake_case(), $s2)
+            }
+        };
+    }
+
+    t!(test1: "CamelCase" => "camel_case");
+    t!(test2: "This is Human case." => "this_is_human_case");
+    t!(test3: "MixedUP CamelCase, with some Spaces" => "mixed_up_camel_case_with_some_spaces");
+    t!(test4: "mixed_up_ snake_case with some _spaces" => "mixed_up_snake_case_with_some_spaces");
+    t!(test5: "kebab-case" => "kebab_case");
+    t!(test6: "SHOUTY_SNAKE_CASE" => "shouty_snake_case");
+    t!(test7: "snake_case" => "snake_case");
+    t!(test8: "this-contains_ ALLKinds OfWord_Boundaries" => "this_contains_all_kinds_of_word_boundaries");
+    t!(test9: "XΣXΣ baﬄe" => "xσxς_baﬄe");
+    t!(test10: "XMLHttpRequest" => "xml_http_request");
+    t!(test11: "FIELD_NAME11" => "field_name11");
+    t!(test12: "99BOTTLES" => "99bottles");
+    t!(test13: "FieldNamE11" => "field_nam_e11");
+
+    t!(test14: "abc123def456" => "abc123def456");
+    t!(test16: "abc123DEF456" => "abc123_def456");
+    t!(test17: "abc123Def456" => "abc123_def456");
+    t!(test18: "abc123DEf456" => "abc123_d_ef456");
+    t!(test19: "ABC123def456" => "abc123def456");
+    t!(test20: "ABC123DEF456" => "abc123def456");
+    t!(test21: "ABC123Def456" => "abc123_def456");
+    t!(test22: "ABC123DEf456" => "abc123d_ef456");
+    t!(test23: "ABC123dEEf456FOO" => "abc123d_e_ef456_foo");
+    t!(test24: "abcDEF" => "abc_def");
+    t!(test25: "ABcDE" => "a_bc_de");
+}
diff --git a/0.3.3/src/title.rs b/0.3.3/src/title.rs
new file mode 100644
index 0000000..015a9fa
--- /dev/null
+++ b/0.3.3/src/title.rs
@@ -0,0 +1,50 @@
+use crate::{capitalize, transform};
+
+/// This trait defines a title case conversion.
+///
+/// In Title Case, word boundaries are indicated by spaces, and every word is
+/// capitalized.
+///
+/// ## Example:
+///
+/// ```rust
+/// use heck::TitleCase;
+///
+/// let sentence = "We have always lived in slums and holes in the wall.";
+/// assert_eq!(sentence.to_title_case(), "We Have Always Lived In Slums And Holes In The Wall");
+/// ```
+pub trait TitleCase: ToOwned {
+    /// Convert this type to title case.
+    fn to_title_case(&self) -> Self::Owned;
+}
+
+impl TitleCase for str {
+    fn to_title_case(&self) -> String {
+        transform(self, capitalize, |s| s.push(' '))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::TitleCase;
+
+    macro_rules! t {
+        ($t:ident : $s1:expr => $s2:expr) => {
+            #[test]
+            fn $t() {
+                assert_eq!($s1.to_title_case(), $s2)
+            }
+        };
+    }
+
+    t!(test1: "CamelCase" => "Camel Case");
+    t!(test2: "This is Human case." => "This Is Human Case");
+    t!(test3: "MixedUP CamelCase, with some Spaces" => "Mixed Up Camel Case With Some Spaces");
+    t!(test4: "mixed_up_ snake_case, with some _spaces" => "Mixed Up Snake Case With Some Spaces");
+    t!(test5: "kebab-case" => "Kebab Case");
+    t!(test6: "SHOUTY_SNAKE_CASE" => "Shouty Snake Case");
+    t!(test7: "snake_case" => "Snake Case");
+    t!(test8: "this-contains_ ALLKinds OfWord_Boundaries" => "This Contains All Kinds Of Word Boundaries");
+    t!(test9: "XΣXΣ baﬄe" => "Xσxς Baﬄe");
+    t!(test10: "XMLHttpRequest" => "Xml Http Request");
+}
